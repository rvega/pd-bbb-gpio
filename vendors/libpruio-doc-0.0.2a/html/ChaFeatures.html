<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>libpruio: Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="pruio.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pruio_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpruio
   &#160;<span id="projectnumber">0.0.2</span>
   </div>
   <div id="projectbrief">AM33xx-PRU driver for digital input / output and analog input</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ChaFeatures.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#SecFunction">Functional Description  </a><ul><li class="level2"><a href="#SubConstructor">Constructor  </a></li>
<li class="level2"><a href="#SubCustomizePin">GPIO Pin Configuration  </a></li>
<li class="level2"><a href="#SubDescripbePin">GPIO Pin Description  </a></li>
<li class="level2"><a href="#SubCustomizeStep">ADC Step Configuration  </a></li>
<li class="level2"><a href="#SubCustomizeAdc">ADC Settings  </a></li>
<li class="level2"><a href="#SubConfig">Config  </a></li>
<li class="level2"><a href="#SubDIO">Digital IO  </a></li>
<li class="level2"><a href="#SubAI">Analog Input  </a></li>
<li class="level2"><a href="#SubStart">Start (MM)  </a></li>
<li class="level2"><a href="#SubTrigPin">Digital Trigger (MM)  </a></li>
<li class="level2"><a href="#SubTrigAin">Analog Trigger (MM)  </a></li>
<li class="level2"><a href="#SubTrigPre">Pre-Trigger (MM)  </a></li>
<li class="level2"><a href="#SubDestructor">Destructor  </a></li>
<li class="level2"><a href="#SubPru01">PRU subsystem  </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>libpruio features in short</p>
<ul>
<li>wakeup devices (GPIO and ADC)</li>
<li>read original devices configuration (if any)</li>
<li>customize GPIO configuration</li>
<li>customizing from user-point-of-view (header pins instead of CPU ball numbers)</li>
<li>create a text description for a GPIO configuration</li>
<li>lock or unlock GPIOs</li>
<li>customize ADC configuration and channel settings</li>
<li>run in IO mode (IO) or measurement mode (MM)</li>
<li>get GPIO input state (IO)</li>
<li>set GPIO output state (IO)</li>
<li>fetch ADC samples continuously (IO)</li>
<li>fetch a given number of samples for a given set of channels (MM)</li>
<li>start measurement by one or up to four trigger events (MM)</li>
<li>absolute or delta triggers (MM)</li>
<li>post-triggers start sampling after a certain time (MM)</li>
<li>pre-trigger starts sampling before the trigger event happened (MM)</li>
<li>transform ADC samples to 13, 14, 15 or 16 bit values</li>
<li>restore previous settings when done (if any)</li>
<li>run either on PRU-0 or PRU-1 (default)</li>
</ul>
<h1><a class="anchor" id="SecFunction"></a>
Functional Description  </h1>
<p>This driver uses a PRU subsystem to operate the ARM devives Control Module, GPIO[0-3] and TSC_ADC_SS. The software can either run on PRU-0 or on PRU-1 (the later is the default) and is highly configurable.</p>
<p>To run this library the PRU subsystems must be enabled and read / write privilegues are necessary to the PRU system interrupt <code>/dev/uio5</code>, see <a class="el" href="ChaPreparation.html">Preparation</a> for details.</p>
<p>Operation gets done in three steps</p>
<ol type="1">
<li>wake up and prepare ADC and GPIO devices, fetch original configuration</li>
<li>configure devices<ul>
<li>customize GPIO settings (optional)</li>
<li>customize ADC channel settings (or use defaults)</li>
<li>upload settings to PRU and start (in IO mode) or wait for start command (in MM mode)</li>
<li>start measurement (MM)</li>
</ul>
</li>
<li>when done, restore original configuration (if any) and destroy driver UDT</li>
</ol>
<p>After configuration the driver software runs on the PRU subsystem in an endless loop. Interrupt this loop by either uploading a new configuration or destroying the driver structure.</p>
<p>The driver either runs in input / output mode (IO) or measurement mode (MM). In IO mode the software on the host (ARM) controls the data flow and the driver continuously transfers values to and from the devices. In MM mode the software on the host starts the execution and then waits until the driver software on the PRU finished the specified measurement.</p>
<p>All parameters for the ADC device are stored local in the PruIo structure and get uploaded by a call the function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a>. GPIO settings can get changed at runtime (in IO mode).</p>
<h2><a class="anchor" id="SubConstructor"></a>
Constructor  </h2>
<p>The constructor <a class="el" href="structPruIo.html#a0a25395a04d03c80cf7fb988a83c94ba">PruIo::PruIo()</a> creates a new driver structure and prepares the devices. It wakes up the GPIO and ADC devices (if powered off) or reads the original configuration (if already running).</p>
<p>The digital input lines (GPIO) are used unchanged. All lines connected to one of the Beaglebone headers P8 or P9 get checked. Each connector (pin) that is configured in mode 7 (GPIO) gets unlocked. Pins in other modes and pins not connected to a header get locked.</p>
<p>A set of ADC step configurations get created with default values. Step 1 to 8 are set to sample inputs AIN0 to AIN7 with an avaraging of 4 samples and an open delay of 200 cycles, resulting in a sampling rate of 10 kilo samples per second. Pass parameters to customize avaranging, open delay and sample delay for the steps in the default configuration.</p>
<p>Later, these default settings can get extended by additional steps or the default steps can get overriden by customized parameters.</p>
<dl class="section note"><dt>Note</dt><dd>Never create more than one instance of the PruIo at a time. They may interfere on memory or interrupt settings. Destroy the first instance before creating a new one.</dd></dl>
<h2><a class="anchor" id="SubCustomizePin"></a>
GPIO Pin Configuration  </h2>
<p>The function <a class="el" href="structPruIo.html#aedfa737c300263c1b4d13df18ade6071">PruIo::gpio_set()</a> is used to customize the configuration of CPU connectors (balls). The Control Module in the ARM processor is used to connect a CPU ball to an internal CPU device. To use a ball as GPIO, it must be set in mode 7. In this mode it can either be an input or an output. Input balls can optionally get connected to a pullup or pulldown resistor. Output balls get set to an initial high or low state (and have no resistor connected by default).</p>
<p>The libpruio user need not care about CPU balls. The extension pruio_pins.bi contains macros to perform configurations from the user point of view. These macros hide the CPU ball number behind an easy to understand name in case of all balls connected to a Beaglebone header (P8 or P9). In contrast to the CPU balls these connectors are called pin in this document. Ie. use 'P8_07' to refer to the CPU ball connected to pin 7 on header P8. The file pruio_pins.bi also contains arrays to easy address groups of pins.</p>
<p>libpruio contains a locking mechanism to protect unintentional pin changes. All balls are locked by default, except the pins (balls connected to a Beaglebone header P8 or P9) that are configured in mode 7 at startup (these get unlocked by the constructor). The user is free to customize the locking by calls to function <a class="el" href="structPruIo.html#aedfa737c300263c1b4d13df18ade6071">PruIo::gpio_set()</a>.</p>
<h2><a class="anchor" id="SubDescripbePin"></a>
GPIO Pin Description  </h2>
<p>The function <a class="el" href="structPruIo.html#a9abb7f95952db7da67be1fccef7a881c">PruIo::gpio_get_config()</a> creates a human readable desription of a current CPU ball setting. Detailed information are generated for balls in mode 7 (GPIO). Otherwise only the mode number gets shown.</p>
<p>This function can be used on all CPU balls. Pins on the headers are named after their position (ie. like "H8_46") and internaly connected CPU balls are named by their Control Module reference number (ie. "b097").</p>
<h2><a class="anchor" id="SubCustomizeStep"></a>
ADC Step Configuration  </h2>
<p>The function <a class="el" href="structPruIo.html#a61a61caae8ef64a5d2d4f2db5de84bc5">PruIo::adc_step()</a> is used to customize the configuration for a single channel. Changes get stored in to the local settings in the driver structure and take into acount after uploading the driver configuration by the next call to function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a>.</p>
<h2><a class="anchor" id="SubCustomizeAdc"></a>
ADC Settings  </h2>
<p>Furthermore (for advanced users) some registers of the ADC device can get influenced by changing the member variables <a class="el" href="structPruIo.html#a3e86b3de65d6883fbc655419bd9c3e1e">PruIo::AdcReg24</a> to <a class="el" href="structPruIo.html#a149cfaecdfb0b266577619c21c1957f1">PruIo::AdcReg40</a> (ie. IRQ and DMA settings). These get uploaded to the ADC device by each call to function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a>.</p>
<h2><a class="anchor" id="SubConfig"></a>
Config  </h2>
<p>The function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a> uploads the local driver configuration (from the host = ARM) and the instructions to the PRU device. And it starts executing the program, which configures the devices Arm Control Module, GPIOs and ADC.</p>
<p>Depending on the requirend number of samples it either immediately starts in IO mode or waits for a call to <a class="el" href="structPruIo.html#a708b5bab7c6f7d3d9a0a5329b13855b7">PruIo::mm_start()</a> in MM mode.</p>
<h2><a class="anchor" id="SubDIO"></a>
Digital IO  </h2>
<p>Digital input and output is available in IO mode. Set the state of an output pin by a call to function <a class="el" href="structPruIo.html#aafb8cbfa0f92385ce8d2c4aeda5fc7d4">PruIo::gpio_out()</a> or get the state of an input or output pin by a call to function <a class="el" href="structPruIo.html#ab30acd999ad5f7f2901a08ffc06a8ba4">PruIo::gpio_get()</a>. You can get the state of all pins, but setting the state is only allowed for unlocked pins in output mode. Use function <a class="el" href="structPruIo.html#aedfa737c300263c1b4d13df18ade6071">PruIo::gpio_set()</a> to change pin mode and locking.</p>
<dl class="section note"><dt>Note</dt><dd>Digital IO is only available in IO mode. It doesn't work in MM mode.</dd></dl>
<h2><a class="anchor" id="SubAI"></a>
Analog Input  </h2>
<p>Analog input is available in IO mode and in MM mode. In MM mode the driver fetches a pre-defined set of samples in real time (and does nothing else). In IO mode the driver updates the ADC samples continuously and the software on the host (ARM) controls when to fetch a value. Switch between both modes by setting the parameter Samp in a call to function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a>.</p>
<p>Refer to the samples of the ADC device by the member array <a class="el" href="structPruIo.html#ac26dfef345950a9734a65fa2febc92d5">PruIo::Value</a>. Its context depends on the execution mode. In IO mode the array contains one value for each step. Non-active steps are set to 0 (= zero). Active steps contain the last sampled value. In MM mode the array contains only valid samples (all zero values of non-active steps get skipped).</p>
<p>The sampled values can get scaled in 12 to 16 bit resolution (ie. to directly compare the values with results from a 16 bit audio device). See parameter Mds for function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a> for details.</p>
<p>In IO mode the sampling rate depends on the configuration of the ADC device and the steps. The parameter ClkDiv and the avaraging, the open and the sample delay values specify the time the ADC device needs to execute a run through all active steps. When such a run is finished the driver starts the ADC device again. (The timing of the re-start may vary a few micro seconds.)</p>
<p>In MM mode the sampling rate gets defined by the parameter Tmr in the call to function <a class="el" href="structPruIo.html#aad8898bd8a39bd0d043f03b82f76ba05">PruIo::config()</a>. In this mode the driver uses an internal CPU timer to garanty maximum timing precision.</p>
<h2><a class="anchor" id="SubStart"></a>
Start (MM)  </h2>
<p>The function <a class="el" href="structPruIo.html#a708b5bab7c6f7d3d9a0a5329b13855b7">PruIo::mm_start()</a> is used to start a measurement in measurement mode (MM). By default (no parameters) the measurement starts immediately. Otherwise the measurement starts after all specified trigger events happend. Up to four trigger events can get specified by parameters. In case of more than one trigger event, the first trigger starts the second, the second starts the third and so on. Measurement doesn't start before all trigger events happened in the given order.</p>
<p>Trigger events can either be specified as an event on a digital or analog line. In case of a digital event the trigger waits until the specified input or output GPIO gets in the given state. In case of an analog trigger a specified ADC step gets executed and the resulting sample gets compared with the trigger setting. Delay times can be added after, but for an analog trigger also before the trigger event happens (see below).</p>
<p>This function is designed for synchronuous calls. It waits until all trigger events occured and the measurement is finished. Enclose it in a thread when you need asynchronous execution. But never execute more than one call at a time. When running in a thread the current state can get checked in the member variable <a class="el" href="structPruIo.html#af1f15a5012917afe710e259f3050695c">PruIo::DRam</a>[0]. See <a class="el" href="ChaMessages.html">Messages</a> for details.</p>
<h2><a class="anchor" id="SubTrigPin"></a>
Digital Trigger (MM)  </h2>
<p>An digital trigger is used to start a measurement in MM. It compares the state of the given CPU ball against the specified trigger value. Input or output balls can be used as trigger.</p>
<p>Use function <a class="el" href="structPruIo.html#a29f45a3f5ac52e623f84a625fcc1c4f7">PruIo::mm_trg_pin()</a> to create a digital trigger specification and pass it in the call to function <a class="el" href="structPruIo.html#a708b5bab7c6f7d3d9a0a5329b13855b7">PruIo::mm_start()</a>.</p>
<p>During the waiting phase only the GPIO state gets checked and the ADC device is in idle mode. After the trigger event happened, the ADC gets started, all configured steps get active and sampling rate slows down to the specified value.</p>
<p>A delay time can get added after the trigger event and before the measurement (or the next trigger) starts.</p>
<h2><a class="anchor" id="SubTrigAin"></a>
Analog Trigger (MM)  </h2>
<p>An analog trigger is used to start a measurement in MM. It compares the current sample of the given ADC step against the specified trigger value. The trigger event happens if the current sample is either greater or less than the specified trigger value. The trigger value can either be an absolute value or it can get specified as relative change.</p>
<p>Use function <a class="el" href="structPruIo.html#ac0d2fd42e59f21cb06ff8d3064dc8e42">PruIo::mm_trg_ain()</a> to create an analog trigger specification and pass it in the call to function <a class="el" href="structPruIo.html#a708b5bab7c6f7d3d9a0a5329b13855b7">PruIo::mm_start()</a>.</p>
<p>During the waiting phase only the trigger step is active and the ADC device runs at maximum sampling rate with the previously configured ADC settings (all other steps are disabled). After the trigger event happened, all configured steps get active and sampling rate slows down to the specified value.</p>
<p>A delay time can get added after the trigger event and before the measurement (or the next trigger) starts.</p>
<h2><a class="anchor" id="SubTrigPre"></a>
Pre-Trigger (MM)  </h2>
<p>An pre-trigger is used to start a measurement in MM. In contrast to the previous triggers a pre-trigger starts measurement before the trigger event happens. This means the measurement gets started immediately, doing all active steps. The samples get stored in a ring buffer, overriding old values when the buffer is full. When the trigger event happens, measurement continues but the samples get stored in the normal buffer (outside the ring buffer). After the measurement the samples in the ring buffer get sorted in the right order.</p>
<p>Currently a pre-trigger only can use an analog input line (but no digital). It's possible to either trigger on one or all active analog steps.</p>
<p>Use function <a class="el" href="structPruIo.html#a966c76b10c14183e9102d3fcefe97a46">PruIo::mm_trg_pre()</a> to create a specification for a pre-trigger and pass it in the call to function <a class="el" href="structPruIo.html#a708b5bab7c6f7d3d9a0a5329b13855b7">PruIo::mm_start()</a>. A pre-trigger is allways the last trigger specification (further specs get ignored).</p>
<h2><a class="anchor" id="SubDestructor"></a>
Destructor  </h2>
<p>The destructor resets the devices Control Module, GPIOs and ADC to the original state. It powers off the devices or restores the original configurations (if they were running on start-up). Then it frees the memory used by the driver structure.</p>
<p>It's possible to override the original configurations (only useful for advanced users and undocumented, check source code and <a href="http://www.ti.com/lit/pdf/spruh73">ARM Reference Guide, chapter 9, 12 and 25</a> for details).</p>
<h2><a class="anchor" id="SubPru01"></a>
PRU subsystem  </h2>
<p>The driver is designed to run either on PRU-0 or PRU-1 subsystem, so you can use the other PRU system for additional purposes. By default it runs on PRU-1 (see <a class="el" href="structPruIo.html#a0a25395a04d03c80cf7fb988a83c94ba">PruIo::PruIo</a> to customize) and uses its DRam memory area. In case of a pre-trigger (in MM mode) the DRam from the other PRU may be used to sort the samples, see <a class="el" href="ChaMemory.html">Memory Organisation</a> for details. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 6 2014 13:22:55 for libpruio by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
